syntax = "proto3";

import "google/api/annotations.proto";

package trmrpc;

service TerminatorServer {
    rpc CloseRecommendations (CloseRecommendationsRequest) returns (CloseRecommendationsResponse);
    rpc RevenueReport (RevenueReportRequest) returns (RevenueReportResponse);
}

message CloseRecommendationsRequest {
    /*
    The minimum amount of time in seconds that a channel should have been
    monitored by lnd to be eligible for close. This value is in place to
    protect against closing of newer channels.
    */
    int64 minimum_monitored = 1;

    /*
    The number of inter-quartile ranges a value needs to be beneath the lower
    quartile/ above the upper quartile to be considered a lower/upper outlier.
    Lower values will be more aggressive in recommending channel closes, and
    upper values will be more conservative. Recommended values are 1.5 for
    aggressive recommendations and 3 for conservative recommendations.
    */
    float outlier_multiplier = 2;

    /*
    Threshold contains the threshold value that is used to recommend channels
    for closure.
    */
    oneof threshold{
        /*
        The threshold percentage uptime over observed lifetime beneath which
        channels will be recommended for closure.
        */
        float uptime_threshold = 3;
    }
  }

message CloseRecommendationsResponse{
    /*
    The total number of channels, before filtering out channels that are
    not eligible for close recommendations.
    */
    int32 total_channels = 1;

    /*
    The number of channels that were considered for close recommendations.
    */
    int32 considered_channels = 2;

    /*
    A map of channels to close recommendations, based out whether they are
    outliers in the uptime dataset. The absence of a channel in this set
    implies that it was not considered for close because it did not meet
    the criteria for close (it is private, or has not been monitored for
    long enough to make a decision).
    */
    repeated Recommendation outlier_recommendations = 3;

    /*
    A set of channel close recommendations, based out whether they are
    beneath the threshold provided in the request. The absence of a channel
    in this set implies that it was not considered for close because it
    did not meet the criteria for close (it is private, or has not been
    monitored for long enough to make a decision).
    */
    repeated Recommendation threshold_recommendations = 4;
}

message Recommendation{
    /*
    The channel point [funding txid: outpoint] of the channel being considered
    for close.
     */
    string chan_point = 1;

    // The value of the metric that close recommendations were based on.
    float value = 2;

    // A boolean indicating whether we recommend closing the channel.
    bool recommend_close = 3;
}

message RevenueReportRequest {
    /*
    The funding transaction outpoints for the channels to generate a revenue
    report for. If this is empty, it will be generated for all open and closed
    channels. Channel funding points should be expressed with the format
    fundingTxID:outpoint.
    */
    repeated string chan_points = 1;

    /*
    Start time is beginning of the range over which the report will be
    generated, expressed as unix epoch offset in seconds.
    */
    uint64 start_time = 2;

    /*
    End time is end of the range over which the report will be
    generated, expressed as unix epoch offset in seconds.
     */
    uint64 end_time = 3;
}

message RevenueReportResponse {
    /*
    Reports is a set of pairwise revenue report generated for the channel(s)
    over the period specified.
    */
    repeated RevenueReport reports = 1;
}

message RevenueReport{
    /*
    Target channel is the channel that the report is generated for; incoming
    fields in the report mean that this channel was the incoming channel,
    and the pair as the outgoing, outgoing fields mean that this channel was
    the outgoing channel and the peer was the incoming channel.
    */
    string target_channel = 1;

    /*
    Pair reports maps the channel point of a peer that we generated revenue
    with to a report detailing the revenue.
    */
    map<string, PairReport> pair_reports = 2;
}

message PairReport {
    /*
    Amount outgoing msat is the amount in millisatoshis that arrived
    on the pair channel to be forwarded onwards by our channel.
    */
    int64 amount_outgoing_msat = 1;

    /*
    Fees outgoing is the amount of fees in millisatoshis that we
    attribute to the channel for its role as the outgoing channel in
    forwards.
    */
    int64 fees_outgoing_msat = 2;

    /*
    Amount incoming msat is the amount in millisatoshis that arrived
    on our channel to be forwarded onwards by the pair channel.
    */
    int64 amount_incoming_msat = 3;

    /*
    Fees incoming is the amount of fees in millisatoshis that we
    attribute to the channel for its role as the incoming channel in
    forwards.
    */
    int64 fees_incoming_msat = 4;
}
